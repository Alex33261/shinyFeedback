---
title: "shinyFeedback Intro"
author: "Andy Merlino"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{ShinyFeedback Introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Functionality

The `shinyFeedback` package displays user friendly messages that appear along side `shiny` inputs.  e.g.

![](feedback-screenshot.png)

`shinyFeedback` currently works with the following `shiny::*Input()` functions:

- `shiny::textInput()`
- `shiny::numericInput()`
- `shiny::selectInput()`
- `shiny::dateInput()`
- `shiny::selectInput()`
- `shiny::sliderInput()`
- `shinyWidgets::pickerInput()`

## Setup

In order to use `shinyFeedback` you need to include the `useShinyFeedback()` function at the top of your UI.

The following is a minimal example of a `shiny` app that uses `shinyFeedback`.  Run the following code in your R console to run the app.

```{r, eval=FALSE}
library(shiny)
library(shinyFeedback)

ui <- fluidPage(
  useShinyFeedback(), # include shinyFeedback
  
  textInput(
    "myInput",
    "Warn if >3 characters",
    value = ""
  )
)

server <- function(input, output, session) {
  observeEvent(input$myInput, {
    
    if (nchar(input$myInput) > 3) {
      showFeedbackWarning(
        inputId = "myInput",
        text = "too many chars"
      )  
    } else {
      hideFeedback("myInput")
    }
    
  })
}

shinyApp(ui, server)
```

The above app has one `textInput()` input in the UI.  In the server function, we write the code to conditionally display a feedback message. If the text input has more than 3 characters, the feeback message is displayed.

```{r, eval=FALSE}
library(shiny)
library(shinyFeedback)

ui <- fluidPage(
  useShinyFeedback(), # include shinyFeedback
  
  numericInput(
    "myInput",
    "Warn > 3; Danger > 5",
    value = 0
  )
)

server <- function(input, output, session) {
  observeEvent(input$myInput, {
    if (input$myInput > 3 && input$myInput <= 5) {
      showFeedbackWarning(
        inputId = "myInput",
        text = "warning"
      )
    } else if (input$myInput > 5) {
      showFeedbackDanger(
        inputId = "myInput",
        text = "Danger"
      )
    } else {
      hideFeedback("myInput")
    }
    
  })
}

shinyApp(ui, server)
```


# `feedback()`

The `feedback()` function is an alternative to using `showFeedback()` and `hideFeedback()`.  With `feedback()` the feedback message is shown/hidden based on whether the `show` argument to `feedback()` is "truthy".  "truthiness" is determined by `shiny::isTruthy()`.  `feedback()` works nicely with reactive expressions that use `shiny::req()` to check the validity of Shiny inputs.  e.g.

```{r, eval=FALSE}
library(shiny)
library(shinyFeedback)

ui <- fluidPage(
  useShinyFeedback(), # include shinyFeedback
  
  selectInput(
    "dataset",
    "Dataset",
    choices = c(
      "airquality",
      "Unknown dataset"
    )
  ),
  
  tableOutput('data_table')
)

server <- function(input, output, session) {
  
  data_out <- reactive({
    req(input$dataset)
    
    dataset_exists <- exists(input$dataset, "package:datasets")
    feedbackWarning("dataset", !dataset_exists, "Unknown dataset")
    req(dataset_exists, cancelOutput = TRUE)

    get(input$dataset, "package:datasets")
  })
  
  output$data_table <- renderTable({
    head(data_out())
  })
}

shinyApp(ui, server)
```


## Usage Inside Shiny Modules

shinyFeedback works inside [shiny modules](https://shiny.rstudio.com/articles/modules.html).

As for all modules, input and output IDs in the module UI code must be wrapped in `shiny::ns()` calls.
Inside your module server code, you need *not* wrap input or output IDs inside `shiny::ns()`; shinyFeedback will automatically prepend the namespace of your current module.

Helpfully, you can also just call `shinyFeedback::useShinyFeedback()` inside the module UI function, neatly encapsulating shinyFeedback and its dependencies inside the module.

Here is a simple example using shinyFeedback inside a module:

```{r, eval=FALSE}
library(shiny)
library(shinyFeedback)

numberInput <- function(id) {
  ns <- NS(id)
  tagList(
    useShinyFeedback(),  # inclusion here is ideal; b/c inside module
    numericInput(
      ns("warningInput"),
      "Warn if Negative",
      value = 0
    )
  )
}

number <- function(input, output, session) {
  observeEvent(input$warningInput, {
    if (input$warningInput < 0) {
      showFeedbackWarning(inputId = "warningInput")
    } else {
      hideFeedback("warningInput")
    }
  })
}

ui <- fluidPage(
  numberInput(id = "numberFoo")
)

server <- function(input, output) {
  callModule(module = number, id = "numberFoo")
}

shinyApp(ui, server)
```



# valueBoxModule

`valueBoxModule` is similar to `shinydashboard::valueBox()` but it moves the UI from 
the server to the ui (i.e. the entire box is not rerendered everytime the value in 
the value box updates; only the actual value is rerendered).  The box is only rendered once
when the page is loaded.  By moving the box content to the UI the value box does not flash onto the screen when rendered.  

`valueBoxModule` also allows for more custom styling of the box colors than `shinydashboard::valueBox()`.

```{r, eval = FALSE}
library(shiny)
library(shinyFeedback)


server <- function(input, output, session) {
  
  count <- reactiveVal(0)
  
  observeEvent(input$counter_button, {
    count(count() + 1)
  })
  
  callModule(
    valueBoxModule,
    "betterBox",
    value = count
  )
}

ui <- fluidPage(
  fluidRow(
    column(
      12,
      actionButton(
        "counter_button",
        "+1"
      )
    )
  ),
  br(),
  fluidRow(
    valueBoxModuleUI(
      "betterBox",
      "Counter",
      icon = icon("rocket")
    )
  )
)


shinyApp(ui, server)
```